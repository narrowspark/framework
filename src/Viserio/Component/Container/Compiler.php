<?php
declare(strict_types=1);
namespace Viserio\Component\Container;

use Closure;
use Narrowspark\PrettyArray\PrettyArray;
use Viserio\Component\Container\Compiler\ArrayCompiler;
use Viserio\Component\Container\Compiler\ClosureCompiler;
use Viserio\Component\Container\Compiler\Container\CompiledContainer;
use Viserio\Component\Container\Compiler\ExtendersCompiler;
use Viserio\Component\Container\Compiler\LazyCompiler;
use Viserio\Component\Container\Compiler\ObjectCompiler;
use Viserio\Component\Contract\Container\Exception\InvalidArgumentException;
use Viserio\Component\Contract\Container\Exception\RuntimeException;

/**
 * @internal
 */
final class Compiler
{
    /**
     * @var array array
     */
    private $entryToMethodMapping = [];

    /**
     * The method name of the compile container extend function.
     *
     * @var string
     */
    private $extendCompiledMethodName;

    /**
     * @var \Viserio\Component\Container\Compiler\Contract\Compiler[]
     */
    private $compilers;

    /**
     * Create a new Compiler instance.
     */
    public function __construct()
    {
        $this->extendCompiledMethodName = $this->generateUniqueMethodName('extend');

        $this->compilers = [
            new ArrayCompiler(),
            new ClosureCompiler(),
            new LazyCompiler(),
            new ObjectCompiler(),
        ];
    }

    /**
     * Compile the container.
     *
     * @param string $cacheDirectory
     * @param array  $bindings
     * @param array  $extenders
     * @param array  $options
     *
     * @throws \ReflectionException
     *
     * @return string the compiled container file name
     */
    public function compile(string $cacheDirectory, array $bindings, array $extenders, array $options = []): string
    {
        \array_unshift($this->compilers, new ExtendersCompiler($this->extendCompiledMethodName, $extenders));

        $options = \array_merge([
            'build_time'   => \time(),
            'class'        => 'CompiledContainer',
            'namespace'    => 'Viserio\Component\Container',
            'parent_class' => CompiledContainer::class,
        ], $options);

        $fileName = \rtrim($cacheDirectory, '/') . '/' . $options['class'] . '.php';

        // The container is already compiled
        if (\file_exists($fileName)) {
            return $fileName;
        }

        // Validate that a valid class name was provided
        if (! \preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*$/', $options['class'])) {
            throw new InvalidArgumentException(\sprintf('The container cannot be compiled: [%s] is not a valid PHP class name.', $options['class']));
        }

        $fileContent = '<?php' . PHP_EOL . 'declare(strict_types=1);' . PHP_EOL;
        $fileContent .= ($options['namespace'] !== null ? 'namespace ' . $options['namespace'] . ';' : '') . PHP_EOL . PHP_EOL;
        $fileContent .= '/**' . PHP_EOL . ' * This class has been auto-generated by Viserio Container Component.' . PHP_EOL . ' */' . PHP_EOL;
        $fileContent .= 'final class ' . $options['class'] . ' extends \\' . \ltrim($options['parent_class'], '\\') . PHP_EOL . '{' . PHP_EOL;

        $functions = '';

        foreach ($bindings as $id => $binding) {
            foreach ($this->compilers as $compiler) {
                if (! $compiler->isSupported($id, $binding)) {
                    continue;
                }

                $uniqueMethodName = $this->generateUniqueMethodName('get');

                $this->entryToMethodMapping[$id] = $uniqueMethodName;

                $functions .= $this->generateMethod($uniqueMethodName, $compiler->compile($id, $binding)) . PHP_EOL;
            }
        }

        $fileContent .= '    protected static $methodMapping = ' . PrettyArray::print($this->entryToMethodMapping, 2) . ';' . PHP_EOL . PHP_EOL;
        $fileContent .= $functions;

        if (\count($extenders) !== 0) {
            $fileContent .= ExtendersCompiler::getExtendFunction($this->extendCompiledMethodName);
        }

        $fileContent .= '}';

        self::createCompilationDirectory(\dirname($fileName));

        $successful = \file_put_contents($fileName, $fileContent);

        if ($successful === false) {
            throw new RuntimeException(\sprintf('Failed to write file [%s].', $fileName));
        }

        return $fileName;
    }

    /**
     * Check if value is compilable.
     *
     * @param mixed $value
     *
     * @return bool
     */
    private function isCompilable($value): bool
    {
        if ($value instanceof Closure) {
            return true;
        }

        if ((\is_string($value) && \class_exists($value)) || \is_object($value) || \is_resource($value)) {
            return false;
        }

        return true;
    }

    /**
     * @param string $directory
     *
     * @return void
     */
    private static function createCompilationDirectory(string $directory): void
    {
        if (! \is_dir($directory) && ! @\mkdir($directory, 0777, true)) {
            throw new InvalidArgumentException(\sprintf('Compilation directory does not exist and cannot be created: %s.', $directory));
        }

        if (! \is_writable($directory)) {
            throw new InvalidArgumentException(\sprintf('Compilation directory is not writable: %s.', $directory));
        }
    }

    /**
     * Generate a unique method name.
     *
     * @param string $prefix
     *
     * @return string
     */
    private function generateUniqueMethodName(string $prefix): string
    {
        return \str_replace('.', '', $prefix . \md5(\uniqid((string) \mt_rand(), true)));
    }

    /**
     * @param string $uniqueMethodName
     * @param string $content
     *
     * @return string
     */
    private function generateMethod(string $uniqueMethodName, string $content): string
    {
        return '    protected function ' . $uniqueMethodName . '()' . PHP_EOL . '    {' . PHP_EOL . $content . PHP_EOL . '    }' . PHP_EOL;
    }
}
