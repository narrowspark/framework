<?php
declare(strict_types=1);
namespace Viserio\Component\Container\Compiler;

use Closure;
use Narrowspark\PrettyArray\PrettyArray;
use Opis\Closure\ReflectionClosure;
use Viserio\Component\Contract\Container\Exception\InvalidArgumentException;
use Viserio\Component\Contract\Container\Exception\RuntimeException;
use Viserio\Component\Contract\Container\Types as TypesContract;

/**
 * @internal
 */
final class Compiler
{
    /**
     * @var array array
     */
    private $entryToMethodMapping = [];

    /**
     * @var array
     */
    private $extenders;

    /**
     * @var string
     */
    private $extendCompiledConcreteMethodName;

    /**
     * Create a new Compiler instance.
     */
    public function __construct()
    {
        $this->extendCompiledConcreteMethodName = $this->generateUniqueMethodName('extend');
    }

    /**
     * Compile the container.
     *
     * @param string $cacheDirectory
     * @param array  $bindings
     * @param array  $extenders
     * @param array  $options
     *
     * @throws \ReflectionException
     *
     * @return string the compiled container file name
     */
    public function compile(string $cacheDirectory, array $bindings, array $extenders, array $options = []): string
    {
        $this->extenders = $extenders;

        $options = \array_merge([
            'build_time'   => \time(),
            'class'        => 'CompiledContainer',
            'namespace'    => 'Viserio\Component\Container',
            'parent_class' => CompiledContainer::class,
        ], $options);

        $fileName = \rtrim($cacheDirectory, '/') . '/' . $options['class'] . '.php';

        // The container is already compiled
        if (\file_exists($fileName)) {
            return $fileName;
        }

        // Validate that a valid class name was provided
        if (! \preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*$/', $options['class'])) {
            throw new InvalidArgumentException(\sprintf('The container cannot be compiled: [%s] is not a valid PHP class name.', $options['class']));
        }

        $fileContent = '<?php' . PHP_EOL . 'declare(strict_types=1);' . PHP_EOL;
        $fileContent .= ($options['namespace'] !== null ? 'namespace ' . $options['namespace'] . ';' : '') . PHP_EOL . PHP_EOL;
        $fileContent .= '/**' . PHP_EOL . ' * This class has been auto-generated by Viserio Container Compiler.' . PHP_EOL . ' */' . PHP_EOL;
        $fileContent .= 'class ' . $options['class'] . ' extends \\' . \ltrim($options['parent_class'], '\\') . PHP_EOL . '{' . PHP_EOL;

        $functions = '';

        foreach ($bindings as $id => $binding) {
            $uniqueMethodName = $this->generateUniqueMethodName('get');

            $this->entryToMethodMapping[$id] = $uniqueMethodName;

            $functions .= $this->generateMethod($uniqueMethodName, $this->compileBinding($id, $binding)) . PHP_EOL;
        }

        $fileContent .= '    protected static $methodMapping = ' . PrettyArray::print($this->entryToMethodMapping, 2) . ';' . PHP_EOL . PHP_EOL;
        $fileContent .= $functions;

        if (\count($this->extenders) !== 0) {
            $fileContent .= '    private function ' . $this->extendCompiledConcreteMethodName . '(array $extenders, &$resolved): void ' . PHP_EOL . '    {' . PHP_EOL .
                '        foreach ($extenders as $extender) {' . PHP_EOL .
                '            $resolved = $this->extendConcrete($resolved, $extender);' . PHP_EOL .
                '        }' . PHP_EOL .
                '    }' . PHP_EOL;
        }

        $fileContent .= '}';

        self::createCompilationDirectory(\dirname($fileName));

        $successful = \file_put_contents($fileName, $fileContent);

        if ($successful === false) {
            throw new RuntimeException(\sprintf('Failed to write file [%s].', $fileName));
        }

        return $fileName;
    }

    /**
     * @param string $id
     * @param array  $binding
     *
     * @throws \ReflectionException
     *
     * @return string
     */
    private function compileBinding(string $id, array $binding): string
    {
        $value = $binding[TypesContract::VALUE];

        if (isset($this->extenders[$id])) {
            $code = '        $resolved = ' . $this->compileValue($value) . ';' . PHP_EOL . PHP_EOL;

            $extenders = \array_map(function (Closure $extender) {
                return 'static ' . $this->getAnalyzedClousure($extender);
            }, $this->extenders[$id]);

            $code .= '        $extenders = [' . PHP_EOL . '        ' . \implode(',' . PHP_EOL . '        ', $extenders) . PHP_EOL . '        ];' . PHP_EOL . PHP_EOL;
            $code .= '        $this->' . $this->extendCompiledConcreteMethodName . '($extenders, $resolved);' . PHP_EOL . PHP_EOL;

            return $code . '        return $resolved;';
        }

        if (\is_string($value) && \class_exists($value) && \method_exists($value, '__invoke')) {
            $code = '$factory = $this->resolveNonBound(' . \var_export($value, true) . ');';

            return $code . '        $this->getFactoryInvoker()->call($factory);';
        }

        return '        return ' . $this->compileValue($value) . ';';
    }

    /**
     * @param \Closure $closure
     *
     * @throws \ReflectionException
     *
     * @return string
     */
    private function compileClosure(Closure $closure): string
    {
        $code = $this->getAnalyzedClousure($closure);

        return '$this->call(static ' . $code . ');';
    }

    /**
     * @param mixed $value
     *
     * @throws \ReflectionException
     *
     * @return string
     */
    private function compileValue($value): string
    {
        if ($value instanceof Closure) {
            return $this->compileClosure($value);
        }

        if (\is_array($value)) {
            $array = \array_map(function ($v) {
                return $this->compileValue($v);
            }, $value);

            return PrettyArray::print($array);
        }

        return \var_export($value, true);
    }

    private function compileObject(string $class, bool $isLazy)
    {
        if ($isLazy) {
            return $this->compileLazy($class);
        }
    }

    private function compileLazy($class)
    {
        return
            '        return $this->proxyFactory->createProxy(' . PHP_EOL .
            '            {$class}' . PHP_EOL .
            '            function (&$wrappedObject, $proxy, $method, $params, &$initializer) {' . PHP_EOL .
            '                $wrappedObject = ' . $this->compileValue($class) . ';' . PHP_EOL .
            '                $initializer = null;' . PHP_EOL .
            '                return true;' . PHP_EOL .
            '            }' . PHP_EOL .
            '        );' . PHP_EOL;
    }

    /**
     * Check if value is compilable.
     *
     * @param mixed $value
     *
     * @return bool
     */
    private function isCompilable($value): bool
    {
        if ($value instanceof Closure) {
            return true;
        }

        if ((\is_string($value) && \class_exists($value)) || \is_object($value) || \is_resource($value)) {
            return false;
        }

        return true;
    }

    /**
     * @param string $directory
     *
     * @return void
     */
    private static function createCompilationDirectory(string $directory): void
    {
        if (! \is_dir($directory) && ! @\mkdir($directory, 0777, true)) {
            throw new InvalidArgumentException(\sprintf('Compilation directory does not exist and cannot be created: %s.', $directory));
        }

        if (! \is_writable($directory)) {
            throw new InvalidArgumentException(\sprintf('Compilation directory is not writable: %s.', $directory));
        }
    }

    /**
     * @param Closure $closure
     *
     * @throws \ReflectionException
     *
     * @return string
     */
    private function getAnalyzedClousure(Closure $closure): string
    {
        $closureAnalyzer = new ReflectionClosure($closure);

        // Trim spaces and the last `;`
        $code = \trim($closureAnalyzer->getCode(), "\t\n\r;");

        return $code;
    }

    /**
     * Generate a unique method name.
     *
     * @param string $prefix
     *
     * @return string
     */
    private function generateUniqueMethodName(string $prefix): string
    {
        return \str_replace('.', '', $prefix . \md5(\uniqid((string) \mt_rand(), true)));
    }

    /**
     * @param string $uniqueMethodName
     * @param string $content
     *
     * @return string
     */
    private function generateMethod(string $uniqueMethodName, string $content): string
    {
        return '    protected function ' . $uniqueMethodName . '()' . PHP_EOL . '    {' . PHP_EOL . $content . PHP_EOL . '    }' . PHP_EOL;
    }
}
